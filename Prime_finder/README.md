编译方式：
	把include添加到头文件搜索路径中，然后编译即可，项目根目录下有一个可执行文件Prime_finder2（MacBook可用）

算法思想：
	首先建一个素数筛选器的对象A，调用成员方法nthPrime，在该方法内部，首先是确定一个小距离tinyN，第一轮循环计数后让最后计数值count离1亿的差距小于tinyN，即跳出第一轮循环。随后从当前筛到的数开始，到用approximate（即N/lnN）的方法估计出来的stop值之间用findNthPrime方法找出第（n-count）个素数，即为所求素数。
	其中最重要的countPrimes计数方法中，调用了SieveOfEratosthenes::sieve这个筛法，而该筛法中具体原理如下：首先根据“WheelFactorization”（https://en.wikipedia.org/wiki/Wheel_factorization） 将1-30、31-60……每30个数分为一组，其中2，3，5的倍数被筛去，除第一组外（这个单独计数）其他各组都剩下8个数，且一一对应有规律，然后将这些不是2，3，5倍数的数每8个数存在1个byte里，在以后筛选时都进行位操作。然后每一轮筛选中存入32KB（默认L1缓存）即一次筛选30*4K个数，每次筛选后将本轮信息存入next数组中，在下一次筛选中拿出来作为初始化参数。由于该方法是在高速缓存中运行，采用位操作且配合轮式分解和埃拉托色尼筛法，因此该关键方法处理速度极快，同时也增加了算法结构的复杂性。

算法描述：
	该算法引用的是kimwalisch/primesieve，开始打算借鉴这一代码然后自己写，但各个函数之间调用关系很复杂，算法也很复杂，耗费了许多时间也没成功，无奈只有直接引用源代码。但我认为这也是优秀完成任务的一种方式（时间非常短），不过我在源代码的基础上进行了一些小的优化，以下会一一列举：
1、由于任务是找到第一亿个素数，故crossOffMultiples中的eratBig_不需要判断，因为不及Big素数范围。
2、修改小距离tinyN，不过对运行时间变化不大。
3、由于一亿是比long long类型小许多的，因此dist不会超出范围，即可以省略越界检验。
注：以上修改并未有明显的速度提升，但让我更加加深了对该代码的理解。

